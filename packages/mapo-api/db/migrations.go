package db

import (
	"database/sql"
	"errors"
	"fmt"
	"time"
)

type Migration struct {
	Name string
	SQL  string
}

func RunMigrations(db *sql.DB) error {
	_, err := db.Exec(`
		CREATE TABLE IF NOT EXISTS migrations (
			name TEXT PRIMARY KEY,
			ts INTEGER
		);
	`)
	fmt.Println("Migrations table initialized")

	migrations := []Migration{
		{
			Name: "create_users",
			SQL: `
			CREATE TABLE IF NOT EXISTS users (
				id TEXT PRIMARY KEY,
				email TEXT,
				display_name TEXT
			);
			`,
		},
		{
			Name: "create_files",
			SQL: `
			CREATE TABLE IF NOT EXISTS files (
				id INTEGER PRIMARY KEY,
				user_id TEXT,
				name TEXT,
				content_base64 TEXT,
				FOREIGN KEY(user_id) REFERENCES users(id)
			);
			`,
		},
		{
			Name: "files_generated_primary_key",
			SQL: `
				ALTER TABLE files ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY;
			`,
		},
		{
			Name: "create_folders",
			SQL: `
			CREATE TABLE IF NOT EXISTS folders (
				id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
				user_id TEXT,
				name TEXT,
				parent_id INTEGER,
				FOREIGN KEY(user_id) REFERENCES users(id),
				FOREIGN KEY(parent_id) REFERENCES folders(id)
			);
			`,
		},
		{
			Name: "add_folder_id_to_files",
			SQL: `
				ALTER TABLE files ADD COLUMN folder_id INTEGER REFERENCES folders(id);
			`,
		},
		{
			Name: "add_created_at_and_last_modified_at_to_files",
			SQL: `
				ALTER TABLE files
				ADD COLUMN created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
				ADD COLUMN last_modified_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP;
			`,
		},
	}

	for _, migration := range migrations {
		err := RunMigration(db, migration)
		if err != nil {
			return fmt.Errorf("failed to run migration: %w", err)
		}
	}
	return err
}

func RunMigration(db *sql.DB, migration Migration) error {
	row := db.QueryRow("SELECT count(*) as count FROM migrations WHERE name = $1;", migration.Name)
	var rowData struct {
		Count int
	}
	err := row.Scan(&rowData.Count)
	if err != nil {
		return fmt.Errorf("failed to query migrations table: %w", err)
	}

	if rowData.Count > 0 {
		fmt.Printf("Migration %s already run\n", migration.Name)
		return nil
	}

	fmt.Printf("Running migration: %s\n\t%s\n", migration.Name, migration.SQL)
	return WithTx(db, func(tx *sql.Tx) error {
		_, err = tx.Exec(migration.SQL)
		if err != nil {
			return fmt.Errorf("failed to execute migration: %w", err)
		}

		_, err = tx.Exec(
			"INSERT INTO migrations (name, ts) VALUES ($1, $2);",
			migration.Name,
			time.Now().Unix(),
		)

		return err
	})
}

// Source: https://www.reddit.com/r/golang/comments/18flz7z/defer_rollback_and_committing_a_transaction_in_a/
func WithTx(db *sql.DB, fn func(tx *sql.Tx) error) error {
	txn, err := db.Begin()
	if err != nil {
		return err
	}
	err = fn(txn)
	if err != nil {
		err2 := txn.Rollback()
		return errors.Join(err, err2)
	}
	return txn.Commit()
}
